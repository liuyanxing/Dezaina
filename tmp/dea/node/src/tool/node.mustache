#pragma once

#include <string>
#include <variant>

#include "common/buffer.h"
#include "message.h"
#include "type.h"

namespace dea::node
{

using  uint = uint32_t;
using string = std::string;
using Buffer = base::Buffer;
using boolean = bool;

{{#classes}}
class {{name}};
{{/classes}}

{{#structs}}
struct {{name}};
{{/structs}}

{{#customType}}
{{&.}}
{{/customType}}

{{#enums}}
enum class {{name}} {
{{#values}}
	{{.}},
{{/values}}
};

{{/enums}}

{{#structs}}
struct {{name}} {{#inherits}}{{.}}{{/inherits}} {
{{#members}}
	{{&type}} {{name}}{{#defaultValue}} = {{defaultValue}}{{/defaultValue}};
{{/members}}

	void applyChange(const message::{{changeType}}& change) {
{{#members}}
		if (change.{{name}}() != nullptr) {
			applyChangeImpl({{name}}, *change.{{name}}());
		}
{{/members}}
	}

	void toChange(message::{{changeType}}& change, kiwi::MemoryPool& pool) const {
{{#members}}
		toChangeImpl(&change, &message::{{changeType}}::set_{{name}}, {{name}}, pool);
{{/members}}
	}

	auto* toChange(kiwi::MemoryPool& pool) const {
		auto* change = pool.allocate<message::{{changeType}}>();
		toChange(*change, pool);
		return change;
	}

};

{{/structs}}

{{#classes}}
class {{name}} {{#inherits}}{{.}}{{/inherits}} {
protected:
{{#members}}
	{{&type}} {{name}}{{#defaultValue}} = {{defaultValue}}{{/defaultValue}};
{{/members}}

public:
{{#methods}}
	
{{/methods}}

	void applyChange(const message::{{changeType}}& change) {
{{#propsMembers}}
		if (change.{{name}}() != nullptr) {
			applyChangeImpl({{name}}, *change.{{name}}());
		}
{{/propsMembers}}
{{#extends}}
		{{.}}::applyChange(change);
{{/extends}}
	}

	void toChange(message::{{changeType}}& change, kiwi::MemoryPool& pool) const {
{{#members}}
		toChangeImpl(&change, &message::{{changeType}}::set_{{name}}, {{name}}, pool);
{{/members}}
{{#extends}}
		{{.}}::toChange(change, pool);
{{/extends}}
	}

};

{{/classes}}

}